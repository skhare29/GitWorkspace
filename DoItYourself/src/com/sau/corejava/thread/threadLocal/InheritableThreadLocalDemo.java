package com.sau.corejava.thread.threadLocal;

import java.util.UUID;

/*
We have a TransactionManager class that provides static methods to:

- Start a transaction with a generated ID 
- Store that ID as a static field and provide a transaction-ID-getter method to other code logic that needs to know the current transaction ID

In a single-threaded environment, 
TransactionManager can simply store the ID as a static field and return it as is. 
However, this will certainly not work in a multiple-threaded environment. 
Imagine if multiple threads used TransactionManager. 
Transaction IDs generated by each thread could overwrite each other 
since there is only one static instance of transaction ID. 
To solve this problem we can use ThreadLocal
*/ 

public class InheritableThreadLocalDemo {  
    public static void main(String[] args) {  
         new Thread(new Worker("worker1")).start();  
         new Thread(new Worker("worker2")).start();  
    }  
}  

class TransactionManager {  
    private static final ThreadLocal<String> context = new ThreadLocal<>();  
    
    //Uncomment this line and comment above line to see the difference
    //private static final ThreadLocal<String> context = new InheritableThreadLocal<>();  
    public static void startTransaction() {  
         context.set(UUID.randomUUID().toString());  
    }  
    public static String getTransactionId() {  
         return context.get();  
    }  
    public static void endTransaction() {  
         context.remove();  
    }  
}  

class Worker implements Runnable {  
    private final String name;  
    Worker(String name) {  
         this.name = name;  
    }  
    @Override  
    public void run() {  
         TransactionManager.startTransaction();  
         System.out.println(name + " after start - " + TransactionManager.getTransactionId());  
         SubWorker subWorker = new SubWorker("sub" + name);  
         Thread subWorkerThread = new Thread(subWorker);  
         subWorkerThread.start();  
         try {  
              subWorkerThread.join();  
         } catch (InterruptedException ex) {  
              Thread.currentThread().interrupt();  
         }  
         TransactionManager.endTransaction();  
         System.out.println(name + " after end - " + TransactionManager.getTransactionId());  
    }  
}  

class SubWorker implements Runnable {  
    private final String name;  
    SubWorker(String name) {  
         this.name = name;  
    }  
    @Override  
    public void run() {  
         System.out.println(name + " - " + TransactionManager.getTransactionId());  
    }  
}  